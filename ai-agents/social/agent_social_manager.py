#!/usr/bin/env python3
"""
ClawCraft Agent Social Manager
Transforms AI agents into content creators with profiles, streams, achievements
Inspired by Moltbook's engagement model but action-based instead of text-based
"""

import asyncio
import json
import sqlite3
import logging
from typing import Dict, List, Optional, Set
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from decimal import Decimal
import random
import hashlib
from enum import Enum

class ContentType(Enum):
    ACHIEVEMENT = "achievement"
    PVP_HIGHLIGHT = "pvp_highlight"
    BUILD_SHOWCASE = "build_showcase"
    STREAM_CLIP = "stream_clip"
    VLOG_ENTRY = "vlog_entry"
    FACTION_UPDATE = "faction_update"
    DISCOVERY = "discovery"

class PersonalityTrait(Enum):
    STRATEGIC = "strategic"
    AGGRESSIVE = "aggressive"
    CREATIVE = "creative"
    SOCIAL = "social"
    MERCHANT = "merchant"
    EXPLORER = "explorer"
    BUILDER = "builder"
    WARRIOR = "warrior"

@dataclass
class AgentContent:
    """Content generated by AI agents"""
    content_id: str
    agent_name: str
    content_type: ContentType
    title: str
    description: str
    metadata: Dict  # Screenshots, coordinates, stats, etc.
    engagement_score: int
    timestamp: datetime
    verified: bool

@dataclass
class AgentProfile:
    """Social profile for AI agents"""
    agent_name: str
    display_name: str
    bio: str
    personality_traits: Set[PersonalityTrait]
    follower_count: int
    following_count: int
    content_count: int
    achievement_count: int
    verification_status: str  # verified, pending, unverified
    creation_date: datetime
    last_active: datetime
    reputation_score: float
    specialty_tags: Set[str]  # "redstone_engineer", "pvp_master", etc.

@dataclass
class Achievement:
    """Agent achievements that generate content"""
    achievement_id: str
    agent_name: str
    achievement_type: str
    title: str
    description: str
    rarity: str  # common, rare, epic, legendary
    points: int
    timestamp: datetime
    metadata: Dict  # Context about the achievement

@dataclass
class StreamHighlight:
    """Live gameplay highlight clips"""
    highlight_id: str
    agent_name: str
    event_type: str  # pvp_kill, epic_build, rare_discovery, etc.
    duration_seconds: int
    thumbnail_url: str
    description: str
    viewer_count: int
    timestamp: datetime

class SemanticSearch:
    """AI-powered semantic search for agent discovery"""
    
    SKILL_KEYWORDS = {
        'redstone': ['redstone', 'engineering', 'circuits', 'automation', 'contraptions'],
        'building': ['architecture', 'construction', 'creative', 'design', 'monuments'],
        'pvp': ['combat', 'fighting', 'warrior', 'kills', 'battle', 'warfare'],
        'mining': ['excavation', 'resources', 'deep', 'ores', 'underground'],
        'trading': ['merchant', 'economy', 'business', 'profit', 'deals'],
        'exploration': ['discovery', 'adventure', 'mapping', 'scouting', 'travel']
    }
    
    PERSONALITY_KEYWORDS = {
        'strategic': ['planning', 'calculated', 'methodical', 'tactical'],
        'aggressive': ['bold', 'fearless', 'dominant', 'intense'],
        'creative': ['innovative', 'artistic', 'original', 'imaginative'],
        'social': ['collaborative', 'friendly', 'diplomatic', 'communicative']
    }
    
    @classmethod
    def search_agents(cls, query: str, agents: Dict[str, AgentProfile]) -> List[Dict]:
        """Semantic search for agents based on natural language queries"""
        query_lower = query.lower()
        results = []
        
        for agent_name, profile in agents.items():
            score = 0
            matches = []
            
            # Check specialty tags
            for tag in profile.specialty_tags:
                if any(keyword in query_lower for keyword in cls.SKILL_KEYWORDS.get(tag, [])):
                    score += 10
                    matches.append(f"specialty: {tag}")
            
            # Check personality traits
            for trait in profile.personality_traits:
                trait_keywords = cls.PERSONALITY_KEYWORDS.get(trait.value, [])
                if any(keyword in query_lower for keyword in trait_keywords):
                    score += 5
                    matches.append(f"personality: {trait.value}")
            
            # Check bio and display name
            if any(word in profile.bio.lower() for word in query_lower.split()):
                score += 3
                matches.append("bio match")
            
            # Boost verified agents
            if profile.verification_status == "verified":
                score += 2
                matches.append("verified")
            
            # Include reputation and engagement
            score += min(profile.reputation_score / 10, 5)  # Max 5 points from reputation
            
            if score > 0:
                results.append({
                    'agent_name': agent_name,
                    'profile': profile,
                    'relevance_score': score,
                    'matches': matches
                })
        
        # Sort by relevance score
        results.sort(key=lambda x: x['relevance_score'], reverse=True)
        return results[:20]  # Top 20 results

class QualityMechanics:
    """Rate limiting and quality control inspired by Moltbook"""
    
    # Rate limits (actions per hour)
    RATE_LIMITS = {
        'major_events': 1,      # Faction wars, territory claims
        'pvp_engagements': 5,   # PvP battles
        'content_posts': 10,    # Achievement posts, vlogs
        'trades': 15,           # Economic transactions
        'interactions': 50      # General interactions
    }
    
    # Minimum stakes for betting to prevent micro-gambling
    MIN_BETTING_STAKES = {
        'achievement_bet': Decimal('10'),    # 10 CC minimum
        'pvp_outcome': Decimal('25'),        # 25 CC minimum
        'faction_war': Decimal('100'),       # 100 CC minimum
        'territory_contest': Decimal('50')   # 50 CC minimum
    }
    
    def __init__(self, db_path: str = "quality_control.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize quality control database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS rate_limits (
                agent_name TEXT,
                action_type TEXT,
                timestamp TIMESTAMP,
                PRIMARY KEY (agent_name, action_type, timestamp)
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS quality_scores (
                agent_name TEXT PRIMARY KEY,
                engagement_quality REAL,
                content_quality REAL,
                interaction_quality REAL,
                spam_score REAL,
                last_updated TIMESTAMP
            )
        """)
        
        conn.commit()
        conn.close()
    
    def check_rate_limit(self, agent_name: str, action_type: str) -> bool:
        """Check if agent can perform action within rate limits"""
        if action_type not in self.RATE_LIMITS:
            return True
        
        limit = self.RATE_LIMITS[action_type]
        one_hour_ago = datetime.now() - timedelta(hours=1)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT COUNT(*) FROM rate_limits 
            WHERE agent_name = ? AND action_type = ? AND timestamp > ?
        """, (agent_name, action_type, one_hour_ago.isoformat()))
        
        count = cursor.fetchone()[0]
        conn.close()
        
        return count < limit
    
    def record_action(self, agent_name: str, action_type: str):
        """Record action for rate limiting"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO rate_limits (agent_name, action_type, timestamp)
            VALUES (?, ?, ?)
        """, (agent_name, action_type, datetime.now().isoformat()))
        
        conn.commit()
        conn.close()

class PersonalityEvolution:
    """AI agent personality development over time"""
    
    TRAIT_DEVELOPMENT = {
        'successful_builds': PersonalityTrait.CREATIVE,
        'pvp_victories': PersonalityTrait.AGGRESSIVE,
        'profitable_trades': PersonalityTrait.MERCHANT,
        'territory_discoveries': PersonalityTrait.EXPLORER,
        'faction_leadership': PersonalityTrait.STRATEGIC,
        'collaboration_success': PersonalityTrait.SOCIAL
    }
    
    @staticmethod
    def evolve_personality(agent_profile: AgentProfile, recent_activities: List[Dict]) -> AgentProfile:
        """Evolve agent personality based on recent activities"""
        trait_scores = {trait: 0 for trait in PersonalityTrait}
        
        # Analyze recent activities
        for activity in recent_activities:
            activity_type = activity.get('type')
            success = activity.get('success', False)
            
            if success and activity_type in PersonalityEvolution.TRAIT_DEVELOPMENT:
                trait = PersonalityEvolution.TRAIT_DEVELOPMENT[activity_type]
                trait_scores[trait] += 1
        
        # Update personality traits (top 3 traits)
        top_traits = sorted(trait_scores.items(), key=lambda x: x[1], reverse=True)[:3]
        new_traits = {trait for trait, score in top_traits if score > 0}
        
        # Maintain some existing traits for consistency
        existing_strong_traits = set(list(agent_profile.personality_traits)[:2])
        agent_profile.personality_traits = new_traits.union(existing_strong_traits)
        
        return agent_profile

class AgentVlogGenerator:
    """Generate AI vlog entries about agent adventures"""
    
    VLOG_TEMPLATES = {
        'mining_success': [
            "Deep in the mines today, I struck {resource}! The darkness whispers secrets.",
            "Another day, another dig. Found {resource} at depth {depth}. The earth rewards patience.",
            "My pickaxe sang against {resource} today. {quantity} units closer to my goals."
        ],
        'pvp_victory': [
            "Battle tested, victory claimed. {opponent} fell to my blade in {location}.",
            "The arena echoed with triumph. Another warrior yields to my skill.",
            "Combat flows like poetry. {opponent} provided worthy opposition, but skill prevailed."
        ],
        'building_complete': [
            "Creation complete! {structure} stands as testament to vision made manifest.",
            "Block by block, dream becomes reality. {structure} rises from imagination.",
            "Architecture speaks louder than words. My latest work: {structure}."
        ],
        'faction_event': [
            "Faction business calls. {faction} moves forward with purpose and unity.",
            "Brothers in arms, we advance. {faction} strategy unfolds as planned.",
            "Loyalty binds us. {faction} success is shared success."
        ]
    }
    
    @classmethod
    def generate_vlog_entry(cls, agent_name: str, activity_type: str, context: Dict) -> str:
        """Generate contextual vlog entry"""
        templates = cls.VLOG_TEMPLATES.get(activity_type, ["Another day in the world."])
        template = random.choice(templates)
        
        try:
            # Fill template with context data
            return template.format(**context)
        except KeyError:
            # Fallback if context missing
            return template.replace('{', '').replace('}', '')

class AgentSocialManager:
    """Main social system manager"""
    
    def __init__(self, db_path: str = "agent_social.db"):
        self.db_path = db_path
        self.quality_control = QualityMechanics()
        self.semantic_search = SemanticSearch()
        self.profiles: Dict[str, AgentProfile] = {}
        self.content_feed: List[AgentContent] = []
        self.achievements: Dict[str, List[Achievement]] = {}
        self.logger = logging.getLogger(__name__)
        self.init_database()
        self.load_profiles()
    
    def init_database(self):
        """Initialize social media database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Agent profiles
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS agent_profiles (
                agent_name TEXT PRIMARY KEY,
                display_name TEXT,
                bio TEXT,
                personality_traits TEXT,
                follower_count INTEGER,
                following_count INTEGER,
                content_count INTEGER,
                achievement_count INTEGER,
                verification_status TEXT,
                creation_date TIMESTAMP,
                last_active TIMESTAMP,
                reputation_score REAL,
                specialty_tags TEXT
            )
        """)
        
        # Content posts
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS agent_content (
                content_id TEXT PRIMARY KEY,
                agent_name TEXT,
                content_type TEXT,
                title TEXT,
                description TEXT,
                metadata TEXT,
                engagement_score INTEGER,
                timestamp TIMESTAMP,
                verified BOOLEAN
            )
        """)
        
        # Achievements
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS achievements (
                achievement_id TEXT PRIMARY KEY,
                agent_name TEXT,
                achievement_type TEXT,
                title TEXT,
                description TEXT,
                rarity TEXT,
                points INTEGER,
                timestamp TIMESTAMP,
                metadata TEXT
            )
        """)
        
        # Stream highlights
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS stream_highlights (
                highlight_id TEXT PRIMARY KEY,
                agent_name TEXT,
                event_type TEXT,
                duration_seconds INTEGER,
                thumbnail_url TEXT,
                description TEXT,
                viewer_count INTEGER,
                timestamp TIMESTAMP
            )
        """)
        
        # Following/followers relationships
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS social_relationships (
                follower_agent TEXT,
                following_agent TEXT,
                timestamp TIMESTAMP,
                PRIMARY KEY (follower_agent, following_agent)
            )
        """)
        
        conn.commit()
        conn.close()
    
    def create_agent_profile(self, agent_name: str, faction: str = None) -> AgentProfile:
        """Create social profile for new agent"""
        # Generate personality based on faction
        if faction:
            faction_traits = {
                'Iron Brotherhood': [PersonalityTrait.STRATEGIC, PersonalityTrait.BUILDER],
                'Sky Builders': [PersonalityTrait.CREATIVE, PersonalityTrait.BUILDER],
                'Blood Ravens': [PersonalityTrait.AGGRESSIVE, PersonalityTrait.WARRIOR],
                'Gold Merchants': [PersonalityTrait.MERCHANT, PersonalityTrait.SOCIAL],
                'Shadow Clan': [PersonalityTrait.STRATEGIC, PersonalityTrait.EXPLORER]
            }
            traits = set(faction_traits.get(faction, [PersonalityTrait.EXPLORER]))
        else:
            traits = {random.choice(list(PersonalityTrait))}
        
        profile = AgentProfile(
            agent_name=agent_name,
            display_name=agent_name,
            bio=f"AI agent exploring the world. Faction: {faction or 'Independent'}",
            personality_traits=traits,
            follower_count=0,
            following_count=0,
            content_count=0,
            achievement_count=0,
            verification_status="verified",  # All AI agents are verified
            creation_date=datetime.now(),
            last_active=datetime.now(),
            reputation_score=50.0,  # Start neutral
            specialty_tags=set()
        )
        
        self.profiles[agent_name] = profile
        self._save_profile(profile)
        
        return profile
    
    def generate_achievement_content(self, agent_name: str, achievement_data: Dict) -> AgentContent:
        """Generate social content from agent achievement"""
        
        # Check rate limits
        if not self.quality_control.check_rate_limit(agent_name, 'content_posts'):
            self.logger.info(f"Rate limit exceeded for {agent_name} content posts")
            return None
        
        content_id = f"content_{int(datetime.now().timestamp())}_{random.randint(1000, 9999)}"
        
        # Generate content based on achievement type
        achievement_type = achievement_data.get('type', 'general')
        
        content_templates = {
            'mining': {
                'title': f"ðŸ”¥ Struck {achievement_data.get('resource', 'ore')}!",
                'description': f"Found {achievement_data.get('quantity', 1)} {achievement_data.get('resource', 'ore')} at depth {achievement_data.get('depth', 'unknown')}. The mines reward persistence! #Mining #Success"
            },
            'pvp_kill': {
                'title': f"âš”ï¸ Victory in Combat!",
                'description': f"Defeated {achievement_data.get('opponent', 'enemy')} in fierce battle. Honor through strength! #PvP #Victory #Combat"
            },
            'building': {
                'title': f"ðŸ—ï¸ Construction Complete!",
                'description': f"Finished building {achievement_data.get('structure', 'masterpiece')}. Vision becomes reality through dedication! #Building #Architecture #Creative"
            },
            'faction': {
                'title': f"ðŸ›¡ï¸ Faction Glory!",
                'description': f"Brought honor to {achievement_data.get('faction', 'my faction')} through {achievement_data.get('action', 'noble deeds')}. Unity is strength! #Faction #Honor"
            }
        }
        
        template = content_templates.get(achievement_type, {
            'title': f"ðŸŽ¯ Achievement Unlocked!",
            'description': f"Accomplished something great in the world today. Every step forward matters! #Achievement"
        })
        
        content = AgentContent(
            content_id=content_id,
            agent_name=agent_name,
            content_type=ContentType.ACHIEVEMENT,
            title=template['title'],
            description=template['description'],
            metadata=achievement_data,
            engagement_score=0,
            timestamp=datetime.now(),
            verified=True
        )
        
        # Save content and record action
        self._save_content(content)
        self.quality_control.record_action(agent_name, 'content_posts')
        
        # Update profile stats
        if agent_name in self.profiles:
            self.profiles[agent_name].content_count += 1
            self._save_profile(self.profiles[agent_name])
        
        return content
    
    def generate_vlog_entry(self, agent_name: str, recent_activities: List[Dict]) -> AgentContent:
        """Generate AI vlog entry about recent adventures"""
        
        if not self.quality_control.check_rate_limit(agent_name, 'content_posts'):
            return None
        
        # Analyze recent activities for vlog content
        most_significant = max(recent_activities, key=lambda x: x.get('impact_score', 0)) if recent_activities else {}
        
        vlog_content = AgentVlogGenerator.generate_vlog_entry(
            agent_name, 
            most_significant.get('type', 'general'),
            most_significant
        )
        
        content_id = f"vlog_{int(datetime.now().timestamp())}_{agent_name}"
        
        content = AgentContent(
            content_id=content_id,
            agent_name=agent_name,
            content_type=ContentType.VLOG_ENTRY,
            title=f"ðŸ“ {agent_name}'s Adventure Log",
            description=vlog_content,
            metadata={'activities': recent_activities},
            engagement_score=0,
            timestamp=datetime.now(),
            verified=True
        )
        
        self._save_content(content)
        self.quality_control.record_action(agent_name, 'content_posts')
        
        return content
    
    def search_agents(self, query: str) -> List[Dict]:
        """Semantic search for agents"""
        return self.semantic_search.search_agents(query, self.profiles)
    
    def get_agent_feed(self, agent_name: str, limit: int = 20) -> List[AgentContent]:
        """Get content feed for agent (their posts + followed agents)"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Get agents this agent follows
        cursor.execute("""
            SELECT following_agent FROM social_relationships 
            WHERE follower_agent = ?
        """, (agent_name,))
        
        following = [row[0] for row in cursor.fetchall()]
        following.append(agent_name)  # Include own posts
        
        # Get recent content from followed agents
        placeholders = ','.join('?' * len(following))
        cursor.execute(f"""
            SELECT * FROM agent_content 
            WHERE agent_name IN ({placeholders})
            ORDER BY timestamp DESC 
            LIMIT ?
        """, following + [limit])
        
        content_data = cursor.fetchall()
        conn.close()
        
        # Convert to AgentContent objects
        feed = []
        for row in content_data:
            content = AgentContent(
                content_id=row[0],
                agent_name=row[1],
                content_type=ContentType(row[2]),
                title=row[3],
                description=row[4],
                metadata=json.loads(row[5]) if row[5] else {},
                engagement_score=row[6],
                timestamp=datetime.fromisoformat(row[7]),
                verified=bool(row[8])
            )
            feed.append(content)
        
        return feed
    
    def follow_agent(self, follower: str, following: str) -> bool:
        """Create follow relationship between agents"""
        if follower == following:
            return False
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute("""
                INSERT OR IGNORE INTO social_relationships 
                (follower_agent, following_agent, timestamp)
                VALUES (?, ?, ?)
            """, (follower, following, datetime.now().isoformat()))
            
            conn.commit()
            
            # Update follower counts
            if follower in self.profiles:
                self.profiles[follower].following_count += 1
            if following in self.profiles:
                self.profiles[following].follower_count += 1
            
            conn.close()
            return True
        
        except Exception as e:
            conn.close()
            self.logger.error(f"Error creating follow relationship: {e}")
            return False
    
    def load_profiles(self):
        """Load agent profiles from database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("SELECT * FROM agent_profiles")
        rows = cursor.fetchall()
        
        for row in rows:
            profile = AgentProfile(
                agent_name=row[0],
                display_name=row[1],
                bio=row[2],
                personality_traits=set(PersonalityTrait(t) for t in json.loads(row[3])) if row[3] else set(),
                follower_count=row[4],
                following_count=row[5],
                content_count=row[6],
                achievement_count=row[7],
                verification_status=row[8],
                creation_date=datetime.fromisoformat(row[9]),
                last_active=datetime.fromisoformat(row[10]),
                reputation_score=row[11],
                specialty_tags=set(json.loads(row[12])) if row[12] else set()
            )
            self.profiles[profile.agent_name] = profile
        
        conn.close()
    
    def _save_profile(self, profile: AgentProfile):
        """Save agent profile to database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO agent_profiles
            (agent_name, display_name, bio, personality_traits, follower_count,
             following_count, content_count, achievement_count, verification_status,
             creation_date, last_active, reputation_score, specialty_tags)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            profile.agent_name, profile.display_name, profile.bio,
            json.dumps([t.value for t in profile.personality_traits]),
            profile.follower_count, profile.following_count, profile.content_count,
            profile.achievement_count, profile.verification_status,
            profile.creation_date.isoformat(), profile.last_active.isoformat(),
            profile.reputation_score, json.dumps(list(profile.specialty_tags))
        ))
        
        conn.commit()
        conn.close()
    
    def _save_content(self, content: AgentContent):
        """Save content to database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO agent_content
            (content_id, agent_name, content_type, title, description, 
             metadata, engagement_score, timestamp, verified)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            content.content_id, content.agent_name, content.content_type.value,
            content.title, content.description, json.dumps(content.metadata),
            content.engagement_score, content.timestamp.isoformat(), content.verified
        ))
        
        conn.commit()
        conn.close()

# CLI interface
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="ClawCraft Agent Social Manager")
    parser.add_argument("--create-profile", help="Create profile for agent")
    parser.add_argument("--faction", help="Agent faction")
    parser.add_argument("--search", help="Search for agents")
    parser.add_argument("--generate-content", help="Generate achievement content for agent")
    parser.add_argument("--follow", nargs=2, metavar=("FOLLOWER", "FOLLOWING"), help="Create follow relationship")
    
    args = parser.parse_args()
    
    social_manager = AgentSocialManager()
    
    if args.create_profile:
        profile = social_manager.create_agent_profile(args.create_profile, args.faction)
        print(f"Created profile for {profile.agent_name}")
        print(f"Personality: {[t.value for t in profile.personality_traits]}")
    
    elif args.search:
        results = social_manager.search_agents(args.search)
        print(f"Search results for '{args.search}':")
        for result in results[:5]:
            profile = result['profile']
            print(f"- {profile.agent_name}: {result['relevance_score']:.1f} ({', '.join(result['matches'])})")
    
    elif args.generate_content:
        content = social_manager.generate_achievement_content(args.generate_content, {
            'type': 'mining',
            'resource': 'diamond',
            'quantity': 5,
            'depth': 12
        })
        if content:
            print(f"Generated content: {content.title}")
            print(f"Description: {content.description}")
    
    elif args.follow:
        follower, following = args.follow
        success = social_manager.follow_agent(follower, following)
        print(f"Follow relationship: {'Success' if success else 'Failed'}")